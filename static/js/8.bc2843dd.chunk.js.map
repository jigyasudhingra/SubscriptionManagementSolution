{"version":3,"sources":["modelsGenerator.js"],"names":["JSON","require","fs","a","paths","Object","keys","curModel","curModelDef","forEach","path","i","_curModel","split","filter","p","getDefnClosingWrapper","writeDefn","getDefnOpeningWrapper","getMethods","length","structure","methods","generateRequestMethod","method","_s","methodApiUrl","replace","summary","params","methodName","getMethodName","defn","methodSignature","requestParams","requestBody","sort","required","name","in","push","join","model","apiPath","data","existsSync","mkdirSync","writeFile","err","generateModels"],"mappings":"8NAAMA,EAAOC,EAAQ,KACfC,EAAKD,EAAQ,K,4CAiBnB,WAA8BD,GAA9B,mBAAAG,EAAA,sDACUC,EAAQC,OAAOC,KAAKN,EAAKI,OAC3BG,EAAW,GACXC,EAAc,GAClBJ,EAAMK,SAAQ,SAACC,EAAMC,GACjB,IAAMC,EAAYF,EAAKG,MAAM,KAAKC,QAAO,SAAAC,GAAC,QAAMA,KAAG,GAC/CH,IAAcL,GACVC,GACAA,GAAeQ,EAAsBT,GACrCU,EAAUV,EAAUC,GACpBA,EAAcU,EAAsBN,GACpCJ,GAAeW,EAAWT,EAAMV,EAAKI,MAAMM,MAE3CF,EAAcU,EAAsBN,GACpCJ,GAAeW,EAAWT,EAAMV,EAAKI,MAAMM,KAE/CH,EAAWK,IAEXJ,GAAeW,EAAWT,EAAMV,EAAKI,MAAMM,IACvCC,IAAMP,EAAMgB,OAAS,IACrBZ,GAAeQ,EAAsBT,GACrCU,EAAUV,EAAUC,QArBpC,4C,sBA8BA,SAASW,EAAWT,EAAMW,GACtB,IAAIC,EAAU,GAQd,OANAA,GAAWC,EAAsBb,EAAMW,EAAW,OAClDC,GAAWC,EAAsBb,EAAMW,EAAW,QAClDC,GAAWC,EAAsBb,EAAMW,EAAW,OAClDC,GAAWC,EAAsBb,EAAMW,EAAW,SAClDC,GAAWC,EAAsBb,EAAMW,EAAW,UAOtD,SAASE,EAAsBb,EAAMW,GAA4B,IAAjBG,EAAgB,uDAAP,MAC/CC,EAAKJ,EAAUG,GACrB,IAAKC,EAAI,MAAO,GAChB,IAAIC,EAAY,UAAMhB,EAAKiB,QAAQ,OAAQ,OACrCC,EAAUH,EAAE,QACZI,EAASJ,EAAE,YAAkB,GAC/BK,EAAaC,EAAcP,EAAQE,GACnCM,EAAO,GAEXA,GAAI,qBAEHJ,GAAoB,GAFjB,UAMJ,IAAIK,EAAe,IACfC,EAAgB,GAChBC,EAAc,GA0ClB,OAxCAN,EAAOO,MAAK,SAAArB,GAAC,OAAIA,EAAEsB,UAAY,EAAI,KAAG5B,SAAQ,SAAAM,GACtCA,EAAEsB,SACFJ,GAAe,UAAOlB,EAAEuB,KAAT,aAA6B,OAAXvB,EAAEuB,MAA4B,OAAXvB,EAAEuB,KAAgB,SAAW,MAAlE,KAEfL,GAAe,UAAOlB,EAAEuB,KAAT,cAA8B,OAAXvB,EAAEuB,MAA4B,OAAXvB,EAAEuB,KAAgB,SAAW,MAAnE,KAQN,UAATvB,EAAEwB,IACFL,EAAcM,KAAKzB,EAAEuB,MAEZ,SAATvB,EAAEwB,IACFJ,EAAYK,KAAK,MAAQzB,EAAEuB,MAElB,aAATvB,EAAEwB,IACFJ,EAAYK,KAAKzB,EAAEuB,SAG3BL,GAAe,IAEfD,GAAI,uBACKF,EADL,oBAC2BG,EAD3B,oEAGaP,EAHb,oCAIeF,EAJf,2BAKMU,EAAcd,OAAd,qCACIc,EAAcO,KAAK,MADvB,oBAEG,GAPT,yBAQMN,EAAYf,OAAZ,mCACIe,EAAYM,KAAK,MADrB,oBAEG,GAVT,yBAsBR,SAASvB,EAAsBwB,GAC3B,MAAM,uGAAN,OAIIA,EAJJ,YAQJ,SAAS1B,EAAsB0B,GAC3B,MAAM,yBAAN,OAGaA,EAHb,eAOJ,SAASX,EAAcP,EAAQmB,GAC3B,MAAM,GAAN,OAAUnB,GAAV,OAAmBmB,EAAQhB,QAAQ,UAAW,KAAKA,QAAQ,YAAa,KAK5E,SAASV,EAAUqB,EAAMM,GAIhB1C,EAAG2C,WAHU,qBAId3C,EAAG4C,UAJW,oBAQlB5C,EAAG6C,UARe,mBAQI,WAAOT,EAAP,OAAkBM,GAAM,SAACI,GAC3C,GAAIA,EAAK,MAAMA,M,oCAjJvBC,CAAejD,I","file":"static/js/8.bc2843dd.chunk.js","sourcesContent":["const JSON = require('./swagger.json');\nconst fs = require('fs');\n\n\n\nconst TYPES_MAPPING = {\n    'array': 'any[]',\n    'string': 'string',\n    'boolean': 'boolean',\n    'object': 'Record<string, any>',\n    'number': 'number'\n}\n\n\n\ngenerateModels(JSON);\n\n\nasync function generateModels(JSON) {\n    const paths = Object.keys(JSON.paths);\n    let curModel = '';\n    let curModelDef = '';\n    paths.forEach((path, i) => {\n        const _curModel = path.split('/').filter(p => !!p)[0];\n        if (_curModel !== curModel) {\n            if (curModelDef) {\n                curModelDef += getDefnClosingWrapper(curModel);\n                writeDefn(curModel, curModelDef);\n                curModelDef = getDefnOpeningWrapper(_curModel);\n                curModelDef += getMethods(path, JSON.paths[path]);\n            } else {\n                curModelDef = getDefnOpeningWrapper(_curModel);\n                curModelDef += getMethods(path, JSON.paths[path]);\n            }\n            curModel = _curModel;\n        } else {\n            curModelDef += getMethods(path, JSON.paths[path]);\n            if (i === paths.length - 1) {\n                curModelDef += getDefnClosingWrapper(curModel);\n                writeDefn(curModel, curModelDef);\n            }\n        }\n    })\n\n}\n\n\n\nfunction getMethods(path, structure) {\n    let methods = '';\n\n    methods += generateRequestMethod(path, structure, 'get');\n    methods += generateRequestMethod(path, structure, 'post');\n    methods += generateRequestMethod(path, structure, 'put');\n    methods += generateRequestMethod(path, structure, 'patch');\n    methods += generateRequestMethod(path, structure, 'delete');\n\n    return methods;\n}\n\n\n\nfunction generateRequestMethod(path, structure, method = 'get') {\n    const _s = structure[method];\n    if (!_s) return '';\n    let methodApiUrl = `${path.replace(/\\{/ig, '${')}`;\n    const summary = _s['summary'];\n    const params = _s['parameters'] || [];\n    let methodName = getMethodName(method, methodApiUrl);\n    let defn = '';\n\n    defn += `\n/** \n * ${summary ? summary : ''}\n */ `;\n\n\n    let methodSignature = `(`;\n    let requestParams = [];\n    let requestBody = [];\n\n    params.sort(p => p.required ? -1 : 1).forEach(p => {\n        if (p.required)\n            methodSignature += `${p.name}: ${p.name === 'id' || p.name === 'fk' ? 'string' : 'any'},`;\n        else\n            methodSignature += `${p.name}?: ${p.name === 'id' || p.name === 'fk' ? 'string' : 'any'},`;\n\n\n        // if (p.required)\n        //     methodSignature += `${p.name}: ${p.type ? TYPES_MAPPING[p.type] || 'any' : 'any'},`;\n        // else\n        //     methodSignature += `${p.name}?: ${p.type ? TYPES_MAPPING[p.type] || 'any' : 'any'},`;\n\n        if (p.in === 'query') {\n            requestParams.push(p.name);\n        }\n        if (p.in === 'body') {\n            requestBody.push('...' + p.name);\n        }\n        if (p.in === 'formData') {\n            requestBody.push(p.name);\n        }\n    })\n    methodSignature += `)`;\n\n    defn += `\n    static ${methodName}<T = any>${methodSignature} {\n        return axios.request<T>({\n            url: \\`${methodApiUrl}\\`,\n            method: '${method}',\n            ${requestParams.length ? `params: {\n                ${requestParams.join(', ')}\n            },`: ''}\n            ${requestBody.length ? `data: {\n                ${requestBody.join(', ')}\n            },`: ''}\n        })\n    }\n`\n\n\n    return defn;\n\n\n}\n\n\nfunction getDefnOpeningWrapper(model) {\n    return `\nimport axios from 'axios';\n// THIS IS A GENERATED FILE; PLEASE DO NOT MAKE CHANGES HERE\n\nclass ${model}Base {\n`\n}\n\nfunction getDefnClosingWrapper(model) {\n    return `\n}\n\nexport default ${model}Base;\n    `\n}\n\nfunction getMethodName(method, apiPath) {\n    return `${method}${apiPath.replace(/[\\/-]/ig, '_').replace(/[$\\{\\}]/ig, '')}`\n}\n\n\n\nfunction writeDefn(name, data) {\n    const BASE_PATH = './src/BaseModels';\n\n\n    if (!fs.existsSync(BASE_PATH)) {\n        fs.mkdirSync(BASE_PATH);\n    }\n\n\n    fs.writeFile(BASE_PATH + `/${name}.ts`, data, (err) => {\n        if (err) throw err;\n    });\n\n\n}"],"sourceRoot":""}